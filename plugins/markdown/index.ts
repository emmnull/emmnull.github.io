import dedent from 'dedent';
import { writeFile } from 'fs/promises';
import { compile } from 'mdsvex';
import { dirname, normalize, relative } from 'path';
import { cwd } from 'process';
import { glob } from 'tinyglobby';
import { loadConfigFromFile, type Plugin } from 'vite';
import type { ZodObject } from 'zod';
import remarkMetadataDefault from './remark-metadata-default';
import remarkMetadataValidate from './remark-metadata-validate';
import remarkPathToImport from './remark-path-to-import';

type Collection<
  P extends Record<string, string | number | boolean | undefined> = Record<
    string,
    string | number | boolean | undefined
  >,
> = {
  /** Optional custom name for collection, defaults to key. */
  name?: string;
  /** Glob pattern(s) for collection content. */
  pattern: string;
  /** Return an object mapping param names to values. */
  params?: (filename: string) => P;
  /** Metadata validation schema. */
  schema: ZodObject;
  /** Optional output path for JSON schema file of metadata schema. */
  json?: string;
};

type MarkdownConfig<
  C extends Record<string, Collection> = Record<string, Collection>,
> = {
  extensions?: string[];
  name?: string;
  types?: string;
  collections?: C;
};

const DEFAULT_CONFIG = {
  extensions: ['.md'],
  name: 'virtual:markdown',
  types: './src/markdown.d.ts',
};

async function getUserConfig(userConfig: Parameters<typeof markdown>[0]) {
  // await import(relative(__dirname, relative(cwd(), userConfig)))
  return typeof userConfig === 'string'
    ? ((
        await loadConfigFromFile(
          { command: 'build', mode: 'development' },
          userConfig,
        )
      )?.config as MarkdownConfig)
    : userConfig;
}

/**
 * Support svelte markdown in vite for more control on timing with other
 * svelte-relevant vite plugins.
 *
 * @todo Move config to separate file to enable automatic type import in
 *   generated declaration.
 */
export default function markdown(
  userConfig: string | MarkdownConfig = 'markdown.config.ts',
): Plugin {
  const config: MarkdownConfig & typeof DEFAULT_CONFIG = DEFAULT_CONFIG;

  let pattern: RegExp;

  /**
   * - Key: filepath.
   * - Value: collection name.
   */
  const contents = new Map<string, string>();

  /**
   * - Key: virtual module name.
   * - Value: collection name.
   */
  const vmods = new Map<
    string,
    {
      name: string;
      params: Record<
        string,
        ReturnType<NonNullable<Collection['params']>> | undefined
      >;
    }
  >();

  return {
    name: 'vite-plugin-markdown-svelte',
    enforce: 'pre',
    async configResolved() {
      Object.assign(config, await getUserConfig(userConfig));
      pattern = new RegExp(`(${config.extensions.join('|')})$`, 'i');
    },
    async buildStart() {
      contents.clear();
      vmods.clear();
      let dts = dedent.withOptions({ trimWhitespace: false })`
				// âš  This file was generated by the markdown vite plugin.
				// Any manual modifications will be overwritten and lost.

				/* eslint-disable @typescript-eslint/no-empty-object-type */

				declare type Markdown<
					T extends Record<string, unknown> = Record<string,unknown>
				> = {
					default: SvelteComponent;
					metadata: T;
				};

				declare module '${config.name}' {
					interface Config {}
				}
				`;
      config.extensions.forEach((ext) => {
        dts += dedent.withOptions({ trimWhitespace: false })`
					declare module '*${ext}' {
						import type { SvelteComponent } from 'svelte';

						export default SvelteComponent;
						export const metadata: Markdown['metadata'];
					}
					`;
      });
      if (config.collections) {
        for (const key in config.collections) {
          const collection = config.collections[key];
          const globbed = await glob(collection.pattern.replace(/^\//, './'));
          globbed.forEach((filepath) => contents.set(filepath, key));
          const sorted = globbed.sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: 'base' }),
          );
          const vname = collection.name ?? `virtual:${key}`;
          const params = Object.fromEntries(
            sorted.map((g) => {
              return ['./' + normalize(g), collection.params?.(g)] as const;
            }),
          );
          vmods.set(vname, { name: key, params });
          dts += dedent.withOptions({ trimWhitespace: false })`
						declare module '${vname}' {
							import type { Config } from '${config.name}';
							import type * as z from 'zod';
							
							type UserConfig = ${typeof userConfig === 'string' ? `typeof import('${relative(dirname(config.types), userConfig)}').default` : 'undefined'};

							type Metadata = UserConfig['collections']['${key}']['schema'] extends z.ZodObject
								? z.infer<UserConfig['collections']['${key}']['schema']>
								: Config.Collections['${key}']['schema'] extends z.ZodObject
									? z.infer<Config.Collections['${key}']['schema']>
									: Markdown['metadata'];

							export const params: readonly ${JSON.stringify(params)};

							export const ids: readonly ${JSON.stringify(Object.keys(params))};

							export type Id = keyof typeof params;

							export type Params = (typeof params)[Id];

							export function all(): (Markdown<Metadata> & { params: Params })[];

							export async function one(
								item: (Id | (string & {})) | (Params | (Record<string, unknown> & {})),
							): Promise<Markdown<Metadata>>;
						}
						`;
        }
      }

      await writeFile(config.types, dts, {
        encoding: 'utf8',
      });
    },
    resolveId(source, _importer, _options) {
      if (vmods.has(source)) {
        return '\0' + source;
      }
    },
    load(id, _options) {
      if (id.startsWith('\0')) {
        const vname = id.replace(/^\0/, '');
        const vmod = vmods.get(vname);
        if (!vmod) {
          return;
        }
        const collection = config.collections?.[vmod.name];
        if (!collection) {
          return;
        }
        const code = dedent`
					export const params = ${JSON.stringify(vmod.params)};

					export const ids = ${JSON.stringify(Object.keys(vmod.params))};

					const params_arr = Object.entries(params);

					const eager = import.meta.glob('${collection.pattern}', {
						eager: true,
						base: './'
					});

					export function all() {
						return Object.entries(eager)
							.map(([id, v]) => {
								return {
									...v,
									id,
									params: params[id],
								}
							});
					}

					export async function one(item) {
						if (typeof item === 'string') {
							return eager[item];
						}
						const id = params_arr.find(p => eq(p[1], item))?.[0];
						if (!id) {
							return;
						}
						return eager[id];
					}

					function eq(a, b) {
						for (const k in a) {
							if (!Object.hasOwn(a, k)) {
								continue;
							}
							if (a[k] !== b[k]) {
								return false;
							}
						}
						return true;
					}
					`;
        return {
          code,
        };
      }
    },
    async transform(code, id) {
      if (pattern.test(id)) {
        const filepath = id.replace(cwd() + '/', '');
        const collname = contents.get(filepath);
        const collection = collname
          ? config.collections?.[collname]
          : undefined;
        const compiled = await compile(code, {
          extensions: config.extensions,
          remarkPlugins: [
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataDefault, { id }],
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataValidate, { schema: collection?.schema }],
            remarkPathToImport,
          ],
        });
        if (compiled) {
          // must only return code and omit compiled.map else breaks vite!?
          return compiled.code;
        }
      }
    },
  };
}

export function defineConfig<C extends MarkdownConfig>(config: C) {
  return config;
}
