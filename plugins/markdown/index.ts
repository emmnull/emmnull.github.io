import dedent from 'dedent';
import { writeFile } from 'fs/promises';
import { compile } from 'mdsvex';
import { dirname } from 'path';
import { glob } from 'tinyglobby';
import type { Plugin } from 'vite';
import type { ZodObject } from 'zod/v4';
import remarkMetadataDefault from './remark-metadata-default';
import remarkMetadataValidate from './remark-metadata-validate';
import remarkPathToImport from './remark-path-to-import';

type MarkdownOptions = {
  extensions: string[];
  // schemas?: Record<string, ZodObject>;
  types?: `${string}.d.ts`;
  collections: Record<
    string,
    {
      name?: string;
      directory: string;
      pattern: string;
      schema: ZodObject;
      json?: string;
    }
  >;
};

/**
 * Support svelte markdown in vite for more control on timing with other
 * svelte-relevant vite plugins.
 */
export default function markdown({
  extensions = ['.md'],
  types = './src/markdown.d.ts',
  collections,
}: MarkdownOptions): Plugin {
  const MARKDOWN_PATTERN = new RegExp(`(${extensions.join('|')})$`, 'i');
  /**
   * - Key: filepath.
   * - Value: collection name.
   */
  const contents = new Map<string, string>();
  /**
   * - Key: virtual module name.
   * - Value: collection name.
   */
  const vmods = new Map<string, { name: string; slugs: Set<string> }>();
  return {
    name: 'vite-plugin-markdown-svelte',
    enforce: 'pre',
    async buildStart() {
      contents.clear();
      vmods.clear();
      let dts = dedent`
				// âš  This file was generated by the markdown vite plugin.
				// Any manual modifications will be overwritten and lost.

				declare type Markdown<
					T extends Record<string,unknown> = Record<string,unknown>
				> = {
					default: SvelteComponent;
					metadata: T
				}
				\n
				`;
      dts += extensions
        .map(
          (ext) => dedent`
					/**
					 * See https://github.com/pngwn/MDsveX/blob/main/packages/mdsvex/globals.d.ts
					 */
					declare module '*${ext}' {
						import type { SvelteComponent } from 'svelte';
					
						export default SvelteComponent;
						export const metadata: Markdown['metadata'];
					}
					\n
			`,
        )
        .join('\n\n');
      if (collections) {
        for (const key in collections) {
          const collection = collections[key];
          const globbed = await glob(
            `${collection.directory}${collection.pattern}`,
          );
          globbed.forEach((filepath) => contents.set(filepath, key));
          const vname = collection.name ?? `virtual:${key}`;
          const slugs = new Set(
            globbed.map((path) =>
              dirname(path).replace(collection.directory, ''),
            ),
          );
          vmods.set(vname, { name: key, slugs });
          dts += dedent`
						declare module '${vname}' {
							import type { z } from 'zod/v4';

							interface Collection {}

							type Metadata = Collection['schema'] extends ZodObject
								? z.infer<Collection['schema']>
								: Markdown['metadata'];

							export const slugs: readonly ${JSON.stringify([...slugs])};
							
							export type Slug = (typeof slugs)[number];
							
							export function all(locale?: Locale): (Markdown<Metadata> & { slug: Slug })[];
							
							export async function one(
								slug: Slug,
								locale?: Locale
							): Promise<Markdown<Metadata>>
						}`;
        }
      }
      await writeFile(types, dts, { encoding: 'utf-8' });
    },
    resolveId(source, _importer, _options) {
      if (vmods.has(source)) {
        return '\0' + source;
      }
    },
    load(id, _options) {
      if (id.startsWith('\0')) {
        const vname = id.replace(/^\0/, '');
        const vmod = vmods.get(vname);
        if (!vmod) {
          return;
        }
        const collection = collections[vmod.name];
        if (!collection) {
          return;
        }
        return {
          code: dedent`
						import { getLocale } from '$lib/i18n/generated/runtime';

						export const slugs = ${JSON.stringify([...vmod.slugs])};

						const glob = import.meta.glob('/${collection.directory}${collection.pattern}', {
							eager: true,
						});

						export function all(locale) {
							const _locale = locale ?? getLocale();
							return Object.entries(glob)
								.filter(([k, v]) => {
									return _locale === k.substring(k.lastIndexOf('/') + 1, k.lastIndexOf('.'))
								})
								.map(([k,v]) => {
									return {
										...v,
										slug: k.substring(0, k.lastIndexOf('/')).replace('/${collection.directory}', ''),
									}
								})
						}

						export async function one(slug, locale) {
							const _locale = locale ?? getLocale();
							return await import(/* @vite-ignore */\`/${collection.directory}\${slug}\${_locale}.md\`);
						}`,
        };
      }
    },
    async transform(code, id) {
      if (MARKDOWN_PATTERN.test(id)) {
        // to do: get schema where q.schema matches a collection name.
        // const qindex = id.indexOf('&');
        // const q = qindex >= 0 && new URLSearchParams(id.substring(qindex));
        const collname = contents.get(id);
        const collection = collname ? collections[collname] : undefined;
        return compile(code, {
          extensions,
          remarkPlugins: [
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataDefault, { id }],
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataValidate, { schema: collection?.schema }],
            remarkPathToImport,
          ],
        });
      }
    },
  };
}

export function defineCollections<T extends MarkdownOptions['collections']>(
  collections: T,
) {
  return collections;
}
