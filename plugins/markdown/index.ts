import { compile } from 'mdsvex';
import type { Plugin } from 'vite';
import type { ZodObject } from 'zod/v4';
import remarkMetadataDefault from './remark-metadata-default';
import remarkPathToImport from './remark-path-to-import';

type MarkdownOptions = {
  extensions: string[];
  schemas?: Record<string, ZodObject>;
  types?: string;
  // content?: {
  //   name: string;
  //   collections: Record<
  //     string,
  //     {
  //       directory: string;
  //       pattern: string;
  //       schema: ZodObject;
  //       json?: string;
  //     }
  //   >;
  // };
};

/**
 * Support svelte markdown in vite for more control on timing with other
 * svelte-relevant vite plugins.
 */
export default function markdown({
  extensions = ['.md'],
  // content,
}: MarkdownOptions): Plugin {
  const MARKDOWN_PATTERN = new RegExp(`(${extensions.join('|')})$`, 'i');
  // /**
  //  * - Key: filepath.
  //  * - Value: collection name.
  //  */
  // const contents = new Map<string, string>();
  // /**
  //  * - Key: virtual module name.
  //  * - Value: collection name.
  //  */
  // const vmods = new Map<string, { name: string; slugs: Set<string> }>();
  return {
    name: 'vite-plugin-markdown-svelte',
    enforce: 'pre',
    // async buildStart() {
    //   contents.clear();
    //   vmods.clear();
    //   if (content) {
    //     const dts: string[] = [
    //       dedent`
    // 			// âš  This file was generated by the markdown vite plugin.
    // 			// Any manual modifications will be overwritten and lost.

    // 			type Content<T extends Record<string,unknown> = Record<string,unknown>> = {
    // 				default: SvelteComponent;
    // 				metadata: T
    // 			}
    // 			`,
    //     ];
    //     for (const name in content.collections) {
    //       const collection = content.collections[name];
    //       const globbed = await glob(
    //         `${collection.directory}${collection.pattern}`,
    //       );
    //       globbed.forEach((filepath) => contents.set(filepath, name));
    //       const vname = `${content.name}/${name}`;
    //       const slugs = new Set(
    //         globbed.map((path) =>
    //           dirname(path).replace(collection.directory, ''),
    //         ),
    //       );
    //       vmods.set(vname, { name, slugs });
    //       dts.push(
    //         dedent`
    // 				declare module '${vname}' {
    // 					export const slugs: readonly ${JSON.stringify([...slugs])};

    // 					export type Slug = (typeof slugs)[number];

    // 					export const all: (Content & { slug: Slug })[];

    // 					export async function one<T>(slug: Slug, locale?: Locale): Promise<Content<T>>
    // 				}
    // 				`,
    //       );
    //     }
    //     console.log(cwd());
    //     await writeFile(
    //       `./src/${content.name.replace(/[^a-z0-9]/gi, '-')}.d.ts`,
    //       dts.join('\n\n'),
    //       { encoding: 'utf-8' },
    //     );
    //   }
    // },
    // resolveId(source, _importer, _options) {
    //   if (vmods.has(source)) {
    //     return '\0' + source;
    //   }
    // },
    // load(id, _options) {
    //   if (id.startsWith('\0')) {
    //     const vname = id.replace(/^\0/, '');
    //     const vmod = vmods.get(vname);
    //     if (!vmod) {
    //       return;
    //     }
    //     const collection = content?.collections[vmod.name];
    //     if (!collection) {
    //       return;
    //     }
    //     return {
    //       code: dedent`
    // 			import { getLocale } from '$lib/i18n/generated/runtime';

    // 			export const slugs = ${JSON.stringify(vmod.slugs)} as const;

    // 			const glob = import.meta.glob('/${collection.directory}${collection.pattern}', { eager: true });

    // 			export const all = [];

    // 			// for () {}

    // 			export async function one(slug, locale) {
    // 				return await import(\`/${collection.directory}\${slug}\${locale ?? getLocale()}.md\`);
    // 			}
    // 			`,
    //     };
    //   }
    // },
    async transform(code, id) {
      if (MARKDOWN_PATTERN.test(id)) {
        // const collname = contents.get(id);
        // const collection = collname
        //   ? content?.collections[collname]
        //   : undefined;
        return compile(code, {
          extensions,
          remarkPlugins: [
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataDefault, { id }],
            // // @ts-expect-error mdsvex types are shite
            // [remarkMetadataValidate, { schema: collection?.schema }],
            remarkPathToImport,
          ],
        });
      }
    },
  };
}
