import dedent from 'dedent';
import { writeFile } from 'fs/promises';
import { compile } from 'mdsvex';
import { dirname } from 'path';
import { glob } from 'tinyglobby';
import type { Plugin } from 'vite';
import type { ZodObject } from 'zod/v4';
import remarkMetadataDefault from './remark-metadata-default';
import remarkPathToImport from './remark-path-to-import';

type MarkdownOptions = {
  extensions: string[];
  // schemas?: Record<string, ZodObject>;
  types?: `${string}.d.ts`;
  collections: Record<
    string,
    {
      name?: string;
      directory: string;
      pattern: string;
      schema: ZodObject;
      json?: string;
    }
  >;
};

/**
 * Support svelte markdown in vite for more control on timing with other
 * svelte-relevant vite plugins.
 */
export default function markdown({
  extensions = ['.md'],
  types = 'markdown.d.ts',
  collections,
}: MarkdownOptions): Plugin {
  const MARKDOWN_PATTERN = new RegExp(`(${extensions.join('|')})$`, 'i');
  /**
   * - Key: filepath.
   * - Value: collection name.
   */
  const contents = new Map<string, string>();
  /**
   * - Key: virtual module name.
   * - Value: collection name.
   */
  const vmods = new Map<string, { name: string; slugs: Set<string> }>();
  return {
    name: 'vite-plugin-markdown-svelte',
    enforce: 'pre',
    async buildStart() {
      contents.clear();
      vmods.clear();
      let dts = dedent`
				// âš  This file was generated by the markdown vite plugin.
				// Any manual modifications will be overwritten and lost.
				
				${extensions
          .map(
            (ext) => dedent.withOptions({ trimWhitespace: false })`
					/**
					 * See https://github.com/pngwn/MDsveX/blob/main/packages/mdsvex/globals.d.ts
					 */
					declare module '*${ext}' {
						import type { SvelteComponent } from 'svelte';

						export default SvelteComponent;
						export const metadata: Record<string, unknown>;
					}
					
				`,
          )
          .join('\n\n')}
    		`;
      if (collections) {
        dts += dedent.withOptions({ trimWhitespace: false })`
					declare module 'virtual:markdown' {
						interface Collections {}
					}

    			type Markdown<T extends Record<string,unknown> = Record<string,unknown>> = {
    				default: SvelteComponent;
    				metadata: T
    			}
					
    			`;
        for (const key in collections) {
          const collection = collections[key];
          const globbed = await glob(
            `${collection.directory}${collection.pattern}`,
          );
          globbed.forEach((filepath) => contents.set(filepath, key));
          const vname = collection.name ?? `virtual:${key}`;
          const slugs = new Set(
            globbed.map((path) =>
              dirname(path).replace(collection.directory, ''),
            ),
          );
          vmods.set(vname, { name: key, slugs });
          dts += dedent`
						declare module '${vname}' {
							import type { z } from 'zod/v4';
							import type { Collections } from 'virtual:markdown';

							type Metadata = Collections.${key}['schema'] extends ZodObject
								? z.infer<Collections.${key}['schema']>
								: Record<string, unknown>;

							export const slugs: readonly ${JSON.stringify([...slugs])};
							export type Slug = (typeof slugs)[number];
							export const all: (Markdown<Metadata> & { slug: Slug })[];
							export async function one(slug: Slug, locale?: Locale): Promise<Markdown<Metadata>>
						}`;
        }
        await writeFile(types, dts, { encoding: 'utf-8' });
      }
    },
    resolveId(source, _importer, _options) {
      if (vmods.has(source)) {
        return '\0' + source;
      }
    },
    load(id, _options) {
      if (id.startsWith('\0')) {
        const vname = id.replace(/^\0/, '');
        const vmod = vmods.get(vname);
        if (!vmod) {
          return;
        }
        const collection = collections[vmod.name];
        if (!collection) {
          return;
        }
        return {
          code: dedent`
						import { getLocale } from '$lib/i18n/generated/runtime';

						export const slugs = ${JSON.stringify([...vmod.slugs])} as const;

						const all = Object.entries(
							import.meta.glob('${collection.directory}${collection.pattern}', { eager: true })
						)
							.map(([k,v]) => ({
								...v,
								slug: k.substring(${collection.directory.length}, k.lastIndexOf('/'))
							}));

						export async function one(slug, locale) {
							return await import(\`${collection.directory}\${slug}\${locale ?? getLocale()}.md\`);
						}
    			`,
        };
      }
    },
    async transform(code, id) {
      if (MARKDOWN_PATTERN.test(id)) {
        // to do: get schema where q.schema matches a collection name.
        // const qindex = id.indexOf('&');
        // const q = qindex >= 0 && new URLSearchParams(id.substring(qindex));
        const collname = contents.get(id);
        const collection = collname ? collections[collname] : undefined;
        return compile(code, {
          extensions,
          remarkPlugins: [
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataDefault, { id }],
            // @ts-expect-error mdsvex types are shite
            [remarkMetadataValidate, { schema: collection?.schema }],
            remarkPathToImport,
          ],
        });
      }
    },
  };
}

export function defineCollections<T extends MarkdownOptions['collections']>(
  collections: T,
) {
  return collections;
}
