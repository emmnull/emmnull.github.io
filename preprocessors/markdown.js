import rehypeShiki from '@shikijs/rehype';
import { writeFileSync } from 'fs';
import { resolve } from 'path';
import rehypeStringify from 'rehype-stringify';
import remarkFrontmatter from 'remark-frontmatter';
import remarkGfm from 'remark-gfm';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import { parse as parseToml } from 'toml';
import { unified } from 'unified';
import { parse as parseYaml } from 'yaml';

const default_extensions = ['.md'];

const default_key = 'metadata';

const dts_filename = resolve('./src/markdown.d.ts');

const module_pattern =
  /^<script\b(?:(?:"[^"]*"|'[^']*'|[^>'"]+))*\bmodule\b(?:(?:"[^"]*"|'[^']*'|[^>'"]+))*>([\s\S]*?)<\/script>/i;

/**
 * @param {Pick<Parameters<typeof markdown>[0], 'extensions' | 'key' | 'schema'>} param0
 */
function writeDts({ extensions, key, schema }) {
  const comment = [
    '/*',
    ' * This type declaration is generated by the markdown preprocessor.',
    ' * Do not modify it, it will be overwritten on next startup.',
    ' */',
  ].join('\n');
  const content = `export default string;`;
  // to do: generate types from schema.
  // schema['~standard'].types is probably not the right thing.
  const meta = `export const ${key}: ${schema?.['~standard']?.types ?? 'Record<string, unknown>'};`;
  const dts = [
    comment,
    ...extensions.map((ext) => {
      return [`declare module '*${ext}' {`, `\t${content}`, `\t${meta}`, '}'].join('\n');
    }),
  ].join('\n\n');
  writeFileSync(dts_filename, dts);
}

/**
 * @param {object} options
 * @param {string[]} options.extensions
 * @param {string} options.key
 * @param {import('unified').Plugin[]} [options.remark]
 * @param {import('unified').Plugin[]} [options.rehype]
 * @param {Record<string, (input: string) => unknown>} [options.parsers]
 * @param {import('@standard-schema/spec').StandardSchemaV1<Record<string, unknown>} [options.schema]
 *
 * @returns {import('svelte/compiler').PreprocessorGroup}
 */
export default function markdown({
  extensions = default_extensions,
  key = default_key,
  parsers: uparsers,
  rehype,
  remark,
  schema,
}) {
  const parsers = {
    yaml: parseYaml,
    toml: parseToml,
    json: JSON.parse,
    ...uparsers,
  };

  /**
   * @param {string} filename
   */
  function isMarkdown(filename) {
    return extensions.some((ext) => filename.endsWith(ext));
  }

  /**
   * @returns {import('unified').Transformer<import('mdast').Root>}
   */
  function remarkParseFrontmatter() {
    return async function (tree) {
      const node = tree.children.find((node) => Object.hasOwn(parsers, node.type));
      if (node) {
        /**
         * @type {(typeof parsers)[keyof typeof parsers]}
         */
        const parse = parsers[node.type];
        /**
         * @type {Record<string, unknown>}
         */
        const fm = parse(node.value);
        if (schema) {
          const valid = await schema['~standard'].validate(fm);
          if (valid.issues) {
            throw Error(JSON.stringify(valid.issues, null, 2));
          }
          //   vfile.data.meta = valid.value;
          // } else {
          //   vfile.data.meta = meta;
        }
        const meta = `export const ${key} = ${JSON.stringify(fm, null, 2)};`;
        const module = tree.children.find(
          (node) => node.type === 'html' && module_pattern.test(node.value),
        );
        // add module script tag, merge if present in markdown
        if (module) {
          module.value = module.value.replace(module_pattern, (match, content) =>
            match.replace(content, content + meta),
          );
        } else {
          tree.children.unshift({ type: 'html', value: `<script module>${meta}</script>` });
        }
      }
      return tree;
    };
  }

  /**
   * @param {string} content
   */
  async function process(content) {
    return await unified()
      .use(remarkParse)
      .use(remarkFrontmatter, [
        'yaml',
        'toml',
        {
          type: 'json',
          fence: { open: '{', close: '}' },
        },
      ])
      .use(remarkParseFrontmatter)
      .use(remarkGfm)
      .use(remark ?? [])
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehype ?? [])
      .use(rehypeShiki, { themes: { light: 'snazzy-light', dark: 'tokyo-night' } })
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(content);
  }

  writeDts({ extensions, key, schema });

  return {
    name: 'markdown',
    async markup(input) {
      if (isMarkdown(input.filename)) {
        return {
          code: (await process(input.content)).toString(),
        };
      }
    },
    // script(input) {
    //   if (isMarkdown(input.filename)) {
    // 		if (input.attributes.module) {
    // 			// what do? merge with front matter or ignore or forbid?
    // 		}
    //   }
    // },
    // style(input) {
    // },
  };
}
